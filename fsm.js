// Generated by CoffeeScript 1.4.0

/*
  
 [Hey, this is CoffeeScript! If you're looking for the original source,
  look in "fsm.coffee", not "fsm.js".]

 Finite State Machine Designer
 portions Copyright (c) Binghamton University,
 author: Kyle J. Temkin <ktemkin@binghamton.edu>

 Based on:
 Finite State Machine Designer (http://madebyevan.com/fsm/)
 portions Copyright (c) 2010 Evan Wallace

 Permission is hereby granted, free of charge, to any person
 obtaining a copy of this software and associated documentation
 files (the "Software"), to deal in the Software without
 restriction, including without limitation the rights to use,
 copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the
 Software is furnished to do so, subject to the following
 conditions:

 The above copyright notice and this permission notice shall be
 included in all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 OTHER DEALINGS IN THE SOFTWARE.
*/


(function() {
  var CircularPath, CrossBrowserUtils, CurvedPath, FSMDesigner, ResetTransition, SelfTransition, State, StraightPath, Transition, TransitionPlaceholder,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  CrossBrowserUtils = (function() {

    function CrossBrowserUtils() {}

    CrossBrowserUtils.true_event = function(e) {
      return e || window.event;
    };

    CrossBrowserUtils.element_position = function(e) {
      var element, position, x, y;
      e = CrossBrowserUtils.true_event();
      element = e.target || e.srcElement;
      x = 0;
      y = 0;
      while (element.offsetParent) {
        x += element.offsetLeft;
        y += element.offsetTop;
        element = element.offsetParent;
      }
      return position = {
        x: x,
        y: y
      };
    };

    CrossBrowserUtils.mouse_position = function(e) {
      var mouse_position;
      e = CrossBrowserUtils.true_event();
      return mouse_position = {
        x: e.pageX || e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft,
        y: e.pageY || e.clientY + document.body.scrollTop + document.documentElement.scrollTop
      };
    };

    CrossBrowserUtils.relative_mouse_position = function(e) {
      var element, mouse, relative_position;
      element = CrossBrowserUtils.element_position(e);
      mouse = CrossBrowserUtils.mouse_position(e);
      return relative_position = {
        x: mouse.x - element.x,
        y: mouse.y - element.y
      };
    };

    CrossBrowserUtils.key_code = function(e) {
      e = CrossBrowserUtils.true_event();
      return e.which || e.keyCode;
    };

    return CrossBrowserUtils;

  })();

  FSMDesigner = (function() {

    FSMDesigner.prototype.snap_to_padding = 20;

    FSMDesigner.prototype.hit_target_padding = 20;

    FSMDesigner.prototype.undo_history_size = 32;

    FSMDesigner.prototype.original_click = null;

    FSMDesigner.prototype.caret_visible = true;

    FSMDesigner.prototype.caret_time = 500;

    FSMDesigner.prototype.selected = null;

    FSMDesigner.prototype.current_transition = null;

    FSMDesigner.prototype.moving_object = false;

    FSMDesigner.prototype.in_output_mode = false;

    FSMDesigner.prototype.textEntryTimeout = null;

    FSMDesigner.prototype.textEnteredRecently = false;

    FSMDesigner.prototype.textUndoDelay = 2000;

    FSMDesigner.prototype.states = [];

    FSMDesigner.prototype.transitions = [];

    FSMDesigner.prototype.undo_stack = [];

    FSMDesigner.prototype.redo_stack = [];

    function FSMDesigner(canvas) {
      var canvas_handlers, event, handler, window_handlers,
        _this = this;
      this.canvas = canvas;
      canvas_handlers = {
        'mousedown': function(e) {
          return _this.handle_mousedown(e);
        },
        'mousemove': function(e) {
          return _this.handle_mousemove(e);
        },
        'mouseup': function(e) {
          return _this.handle_mouseup(e);
        },
        'mousedown': function(e) {
          return _this.handle_mousedown(e);
        },
        'dblclick': function(e) {
          return _this.handle_doubleclick(e);
        },
        'drop': function(e) {
          return _this.handle_drop(e);
        }
      };
      for (event in canvas_handlers) {
        handler = canvas_handlers[event];
        this.canvas.addEventListener(event, handler, false);
      }
      window_handlers = {
        'keypress': function(e) {
          return _this.handle_keypress(e);
        },
        'keydown': function(e) {
          return _this.handle_keydown(e);
        },
        'keyup': function(e) {
          return _this.handle_keyup(e);
        }
      };
      for (event in window_handlers) {
        handler = window_handlers[event];
        window.addEventListener(event, handler, false);
      }
    }

    FSMDesigner.ModalBehaviors = {
      POINTER: 'pointer',
      CREATE: 'create'
    };

    FSMDesigner.KeyCodes = {
      BACKSPACE: 8,
      SHIFT: 16,
      DELETE: 46,
      UNDO: 26,
      REDO: 25,
      z: 122,
      Z: 90
    };

    FSMDesigner.prototype.autosave = function() {
      if (!((typeof localStorage !== "undefined" && localStorage !== null) && (typeof JSON !== "undefined" && JSON !== null))) {
        return;
      }
      return localStorage['fsm'] = this.serialize();
    };

    FSMDesigner.prototype.clear = function(no_save) {
      if (!no_save) {
        this.save_undo_step();
      }
      this.states = [];
      this.transitions = [];
      this.selected = null;
      this.current_target = null;
      return this.draw();
    };

    FSMDesigner.convert_latex_shorthand = function(text) {
      return text;
    };

    FSMDesigner.prototype.create_state_at_location = function(x, y, dont_draw) {
      if (dont_draw == null) {
        dont_draw = false;
      }
      this.save_undo_step();
      this.selected = new State(x, y, this);
      this.states.push(this.selected);
      this.reset_caret();
      if (!dont_draw) {
        return this.draw();
      }
    };

    FSMDesigner.prototype.create_transition_cue = function(mouse) {
      var target_state;
      target_state = this.find_state_at_position(mouse.x, mouse.y);
      if (this.selected != null) {
        this.current_transition = target_state === this.selected ? new SelfTransition(this.selected, this, mouse) : target_state != null ? new Transition(this.selected, target_state, this) : new TransitionPlaceholder(this.selected.closest_point_on_border(mouse), mouse, this);
      } else {
        this.current_transition = target_state != null ? new ResetTransition(target_state, this.original_click, this) : new TransitionPlaceholder(this.original_click, mouse);
      }
      return this.draw();
    };

    FSMDesigner.prototype.dehydrate = function() {
      var designer_state, s, t;
      designer_state = {
        states: (function() {
          var _i, _len, _ref, _results;
          _ref = this.states;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            s = _ref[_i];
            _results.push(this.dehydrate_state(s));
          }
          return _results;
        }).call(this),
        transitions: (function() {
          var _i, _len, _ref, _results;
          _ref = this.transitions;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            t = _ref[_i];
            _results.push(this.dehydrate_transition(t));
          }
          return _results;
        }).call(this)
      };
      return designer_state;
    };

    FSMDesigner.prototype.dehydrate_state = function(state) {
      var dehydrated;
      dehydrated = {
        x: state.x,
        y: state.y,
        text: state.text,
        outputs: state.outputs,
        is_accept_state: state.is_accept_state,
        radius: state.radius
      };
      return dehydrated;
    };

    FSMDesigner.prototype.dehydrate_transition = function(transition) {
      var dehydrated;
      if (transition instanceof SelfTransition) {
        dehydrated = {
          type: 'SelfTransition',
          state: this.states.indexOf(transition.state),
          text: transition.text,
          anchor_angle: transition.anchor_angle
        };
      } else if (transition instanceof ResetTransition) {
        dehydrated = {
          type: 'ResetTransition',
          states: this.states.indexOf(transition.state),
          text: transition.text,
          delta_x: transition.delta_x,
          delta_y: transition.delta_y
        };
      } else if (transition instanceof Transition) {
        dehydrated = {
          type: 'Transition',
          source: this.states.indexOf(transition.source),
          destination: this.states.indexOf(transition.destination),
          line_angle_adjustment: transition.line_angle_adjustment,
          parallel_part: transition.parallel_part,
          perpendicular_part: transition.perpendicular_part
        };
      }
      return dehydrated;
    };

    FSMDesigner.prototype["delete"] = function(obj) {
      this.delete_state(obj);
      return this.delete_transition(obj);
    };

    FSMDesigner.prototype.delete_state = function(state, no_redraw, no_save) {
      var s, selected, t;
      if (no_redraw == null) {
        no_redraw = false;
      }
      if (no_save == null) {
        no_save = false;
      }
      if (__indexOf.call(this.states, state) < 0) {
        return;
      }
      if (!no_save) {
        this.save_undo_step();
      }
      if (selected === state) {
        selected = null;
      }
      this.states = (function() {
        var _i, _len, _ref, _results;
        _ref = this.states;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          s = _ref[_i];
          if (s !== state) {
            _results.push(s);
          }
        }
        return _results;
      }).call(this);
      this.transitions = (function() {
        var _i, _len, _ref, _results;
        _ref = this.transitions;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          t = _ref[_i];
          if (!transition.connectedTo(state)) {
            _results.push(t);
          }
        }
        return _results;
      }).call(this);
      if (!no_redraw) {
        return this.draw();
      }
    };

    FSMDesigner.prototype.delete_transition = function(transition, no_redraw, no_save) {
      var selected, t;
      if (no_redraw == null) {
        no_redraw = false;
      }
      if (no_save == null) {
        no_save = false;
      }
      if (__indexOf.call(this.transitions, transition) < 0) {
        return;
      }
      if (!no_save) {
        this.save_undo_step();
      }
      if (selected === transition) {
        selected = null;
      }
      this.transitions = (function() {
        var _i, _len, _ref, _results;
        _ref = this.transitions;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          t = _ref[_i];
          if (t !== transition) {
            _results.push(t);
          }
        }
        return _results;
      }).call(this);
      if (!no_redraw) {
        return this.draw();
      }
    };

    FSMDesigner.prototype.draw = function() {
      var context;
      context = this.canvas.getContext('2d');
      this.handle_resize();
      this.draw_using(context);
      return this.autosave();
    };

    FSMDesigner.draw_text = function(context, text, x, y, is_selected, font, angle) {
      var corner_point_x, corner_point_y, cos, sin, slide, text_size;
      if (angle == null) {
        angle = null;
      }
      text = FSMDesigner.convert_latex_shorthand(text);
      context.font = font;
      text_size = context.measureText(text, font);
      x -= text_size.width / 2;
      if (angle != null) {
        cos = Math.cos(angle);
        sin = Math.sin(angle);
        corner_point_x = (text_size.width / 2 + 5) * (cos > 0 ? 1 : -1);
        corner_point_y = (10 + 5) * (sin > 0 ? 1 : -1);
        slide = sin * Math.pow(Math.abs(sin), 40) * corner_point_x - cos * Math.pow(Math.abs(cos), 10) * corner_point_y;
        x += corner_point_x - sin * slide;
        y += corner_point_y - cos * slide;
      }
      x = Math.round(x);
      y = Math.round(y);
      context.fillText(text, x, y + 6);
      if (is_selected && this.caret_visible && this.hasFocus() && doucment.hasFocus()) {
        c.beginPath();
        c.moveTo(x + text_size.width, y - text_size.height / 2);
        c.lineTo(x + text_size.width, y + text_size.height / 2);
        return c.stroke();
      }
    };

    FSMDesigner.prototype.draw_using = function(context) {
      var state, transition, _i, _j, _len, _len1, _ref, _ref1, _ref2;
      context.clearRect(0, 0, this.canvas.width, this.canvas.height);
      context.save();
      context.translate(0.5, 0.5);
      _ref = this.states;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        state = _ref[_i];
        state.draw_using(context);
      }
      _ref1 = this.transitions;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        transition = _ref1[_j];
        transition.draw_using(context);
      }
      if ((_ref2 = this.current_transition) != null) {
        _ref2.draw_using(context);
      }
      return context.restore();
    };

    FSMDesigner.prototype.export_png = function() {
      var png_data, temp_selected;
      temp_selected = this.selected;
      this.selected = null;
      this.draw();
      png_data = canvas.toDataURL('image/png');
      window.open(png_data, '_blank');
      window.focus();
      this.selected = temp_selected;
      return this.draw();
    };

    FSMDesigner.prototype.find_object_at_position = function(x, y) {
      return this.find_state_at_position(x, y) || this.find_transition_at_position(x, y);
    };

    FSMDesigner.prototype.find_state_at_position = function(x, y) {
      var state, _i, _len, _ref;
      _ref = this.states;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        state = _ref[_i];
        if (state.contains_point(x, y)) {
          return state;
        }
      }
      return null;
    };

    FSMDesigner.prototype.find_transition_at_position = function(x, y) {
      var transition, _i, _len, _ref;
      _ref = this.transitions;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        transition = _ref[_i];
        if (transition.contains_point(x, y)) {
          return transition;
        }
      }
      return null;
    };

    FSMDesigner.prototype.handle_drop = function(e) {
      e.stopPropagation();
      e.preventDefault();
      if (e.dataTransfer.files.length !== 1) {
        return;
      }
      return this.load_from_file(e.dataTransfer.files[0]);
    };

    FSMDesigner.prototype.handle_backspace = function() {
      if (this.inOutputMode && this.selected.outputs) {
        return this.selected.outputs = this.selected.outputs.slice(0, -1);
      } else if (this.selected.text) {
        return this.selected.text = this.selected.text.slice(0, -1);
      }
    };

    FSMDesigner.prototype.handle_doubleclick = function(e) {
      var mouse;
      mouse = CrossBrowserUtils.relative_mouse_position(e);
      this.selected = this.find_object_at_position(mouse.x, mouse.y);
      this.reset_text_entry();
      this.in_output_mode = false;
      if (this.selected == null) {
        this.create_state_at_location(mouse.x, mouse.y);
      } else if (this.selected instanceof State) {
        this.in_output_mode = true;
      }
      return this.draw();
    };

    FSMDesigner.prototype.handle_keydown = function(e) {
      var key;
      key = CrossBrowserUtils.key_code(e);
      if (key === FSMDesigner.KeyCodes.SHIFT) {
        this.modal_behavior = FSMDesigner.ModalBehaviors.CREATE;
      }
      if (!this.hasFocus()) {
        return;
      }
      if (key === FSMDesigner.KeyCodes.BACKSPACE) {
        this.save_text_undo_step();
        this.handle_backspace();
        this.reset_caret();
        this.draw();
        return false;
      }
      if (key === FSMDesigner.KeyCodes.DELETE) {
        return this.delete_object(this.selected);
      }
    };

    FSMDesigner.prototype.handle_keypress = function(e) {
      var key;
      if (!this.has_focus()) {
        return;
      }
      key = CrossBrowserUtils.key_code(e);
      if (FSMDesigner.keypress_is_printable(e)) {
        this.handle_text_entry(key);
        return false;
      }
      if (FSMDesigner.keypress_represents_undo(e)) {
        this.undo();
        return false;
      }
      if (FSMDesigner.keypress_represents_redo(e)) {
        this.redo();
        return false;
      }
      if (key === FSMDesigner.KeyCodes.BACKSPACE) {
        return false;
      }
    };

    FSMDesigner.prototype.handle_keyup = function(e) {
      var key;
      key = CrossBrowserUtils.key_code(e);
      console.log("Hey, sorry to bother you, but the key is up, you know. The key was, uhh, " + key + ", or something?");
      if (key === FSMDesigner.KeyCodes.SHIFT) {
        return this.modal_behavior = FSMDesigner.ModalBehaviors.POINTER;
      }
    };

    FSMDesigner.prototype.handle_mousedown = function(e) {
      var mouse;
      if (this.dialog_open) {
        return;
      }
      mouse = CrossBrowserUtils.relative_mouse_position(e);
      this.moving_object = false;
      this.in_output_mode = false;
      this.original_click = false;
      this.reset_text_entry();
      this.selected = this.find_object_at_position(mouse.x, mouse.y);
      if (this.selected != null) {
        if (this.modal_behavior === FSMDesigner.ModalBehaviors.CREATE && this.selected instanceof State) {
          this.current_transition = new SelfTransition(this.selected, mouse, this);
        } else if (this.modal_behavior === FSMDesigner.ModalBehaviors.POINTER) {
          this.start_moving_selected(mouse);
        } else if (this.modal_behavior === FSMDesigner.ModalBehaviors.CREATE) {
          this.current_transition = TransitionPlaceholder(mouse, mouse);
        }
        this.draw();
        if (this.hasFocus()) {
          return false;
        }
        this.reset_caret();
        return true;
      }
    };

    FSMDesigner.prototype.handle_mousemove = function(e) {
      var mouse;
      if (this.dialog_open) {
        return;
      }
      mouse = CrossBrowserUtils.relative_mouse_position(e);
      if (this.current_transition != null) {
        this.create_transition_cue(mouse);
      }
      if (this.moving_object) {
        return this.handle_object_move(mouse);
      }
    };

    FSMDesigner.prototype.handle_mouseup = function(e) {
      if (this.dialog_open) {
        return;
      }
      this.moving_object = false;
      if (this.current_transition != null) {
        if (!(this.current_transition instanceof TransitionPlaceholder)) {
          this.save_undo_step();
          this.selected = this.current_link;
          this.reset_text_entry();
          this.transitions.push(this.current_transition);
          this.reset_caret();
        }
      }
      this.current_transition = null;
      return this.draw();
    };

    FSMDesigner.prototype.handle_object_move = function(mouse) {
      this.selected.move_with_offset(mouse);
      if (this.selected instanceof State) {
        this.handle_state_snap();
      }
      return this.draw();
    };

    FSMDesigner.prototype.handle_state_snap = function() {
      var distance, state, _i, _len, _ref, _results;
      _ref = this.states;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        state = _ref[_i];
        if (state === this.selected) {
          continue;
        }
        distance = state.distance_to(this.selected);
        if (Math.abs(distance.x) < this.snap_to_padding) {
          this.selected.x = state.x;
        }
        if (Math.abs(distance.y) < this.snap_to_padding) {
          _results.push(this.selected.y = state.yu);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    FSMDesigner.prototype.handle_text_entry = function(key) {
      if (this.selected == null) {
        return;
      }
      this.save_text_undo_step();
      if (this.in_output_mode && (this.selected.outputs != null)) {
        this.selected.outputs += String.fromCharCode(key);
      } else {
        this.selected.text += String.fromCharCode(key);
      }
      this.reset_caret();
      return this.draw();
    };

    FSMDesigner.prototype.hasFocus = function() {
      if (document.getElementById('helppanel').style.visibility === 'visible') {
        return false;
      }
      return document.activeElement || document.body === document.body;
    };

    FSMDesigner.keypress_is_printable = function(e) {
      var key;
      key = CrossBrowserUtils.key_code(e);
      return key >= 0x20 && key <= 0x7E && !e.metaKey && !e.altKey && !e.ctrlKey;
    };

    FSMDesigner.keypress_represents_redo = function(e) {
      var key;
      key = CrossBrowserUtils.key_code(e);
      return (key === FSMDesigner.KeyCodes.Y && e.ctrlKey) || (key === FSMDesigner.KeyCodes.REDO) || (key === FSMDesigner.KeyCodes.z && e.ctrlKey && e.shiftKey) || (key === FSMDesigner.KeyCodes.UNDO && e.shiftKey);
    };

    FSMDesigner.keypress_represents_undo = function(e) {
      var key;
      key = CrossBrowserUtils.key_code(e);
      return (key === FSMDesigner.KeyCodes.z && e.ctrlKey && !e.shiftKey) || (key === FSMDesigner.KeyCodes.UNDO && !e.shiftKey);
    };

    FSMDesigner.prototype.load_from_file = function(file) {
      var reader;
      this.save_undo_step();
      reader = new FileReader();
      reader.onload = function(file) {
        return this.unserialize(file.target.result);
      };
      return reader.readAsText(file);
    };

    FSMDesigner.prototype.redo = function() {
      if (this.redo_stack.length === 0) {
        return;
      }
      this.save_undo_step();
      this.recreate_state(this.redo_stack.pop());
      return this.draw();
    };

    FSMDesigner.rehydrate = function(dehydrated, canvas) {
      var designer;
      designer = new FSMDesigner(canvas);
      designer.replace_with_rehydrated(dehydrated);
      return designer;
    };

    FSMDesigner.prototype.rehydrate_state = function(dehydrated) {
      var state;
      state = new State(dehydrated.x, dehydrated.y, this);
      state.is_accept_state = dehydrated.is_accept_state;
      state.text = dehydrated.text;
      state.outputs = dehydrated.outputs;
      state.radius = dehydrated.radius;
      return state;
    };

    FSMDesigner.prototype.rehydrate_transition = function(dehydrated) {
      var destination, source, state, transition;
      transition = null;
      switch (dehydrated.type) {
        case 'SelfTransition':
        case 'SelfLink':
          state = this.states[dehydrated.state || dehydrated.node];
          transition = new SelfTransition(state, null, this);
          transition.anchor_angle = dehydrated.anchor_angle || dehydrated.anchorAngle;
          transition.text = dehydrated.text;
          break;
        case 'StartTransition':
        case 'StartLink':
          state = this.states[dehydrated.state || dehydrated.node];
          transition = new StartTransition(this.states[state], null, this);
          transition.delta_x = dehydrated.delta_x || dehydrated.deltaX;
          transition.delta_y = dehydrated.delta_y || dehydrated.deltaY;
          transition.text = dehydrated.text;
          break;
        case 'Transition':
        case 'Link':
          source = this.states[dehydrated.source || dehydrated.nodeA];
          destination = this.states[dehydrated.destination || dehydrated.nodeB];
          transition = new Transition(source, destination, this);
          transition.parallel_part = dehydrated.parallel_part || dehydrated.parallelPart;
          transition.perpendicular_part = dehydrated.perpendicular_part || dehydrated.perpendicularPart;
          transition.text = dehydrated.text;
          transition.line_angle_adjustment = dehydrated.line_angle_adjustment || dehydrated.lineAngleAdjust;
      }
      return transition;
    };

    FSMDesigner.prototype.replace_with_rehydrated = function(dehyrated) {
      var s, states, t, transitions;
      this.clear(true);
      states = dehydrated.states || dehydrated.nodes;
      transitions = dehydrated.transitions || dehydrated.nodes;
      this.states = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = states.length; _i < _len; _i++) {
          s = states[_i];
          _results.push(this.rehydrate_state(s));
        }
        return _results;
      }).call(this);
      this.transitions = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = transitions.length; _i < _len; _i++) {
          t = transitions[_i];
          _results.push(this.rehydrate_transition(t));
        }
        return _results;
      }).call(this);
      return this.draw();
    };

    FSMDesigner.prototype.reset_text_entry = function() {
      if (this.text_entry_timeout != null) {
        clearTimeout(this.text_entry_timeout);
        return this.text_entry_timeout = null;
      }
    };

    FSMDesigner.prototype.reset_caret = function() {
      var _this = this;
      clearInterval(this.caret_timer);
      this.caret_timer = setInterval((function() {
        return _this.toggle_caret();
      }), this.caret_time);
      return this.caret_visible = true;
    };

    FSMDesigner.prototype.handle_resize = function() {
      var context;
      context = this.canvas.getContext('2d');
      context.canvas.width = window.innerWidth;
      context.canvas.height = window.innerHeight - document.getElementById("toolbar").offsetHeight;
      context.canvas.style.width = window.innerWidth + 'px';
      return context.canvas.style.height = (window.innerHeight - document.getElementById('toolbar').offsetHeight) + 'px';
    };

    FSMDesigner.prototype.save_file_data_uri = function() {
      var content, uri_content;
      content = this.serialize();
      uri_content = 'data:application/x-fsm,' + encodeURIComponent(content);
      return document.location.href = uri_content;
    };

    FSMDesigner.prototype.save_undo_step = function() {
      var last_state, state;
      state = this.dehydrate();
      last_state = this.undo_stack.slice(-1);
      if (FSMDesigner.states_equivalent(state, last_state)) {
        return;
      }
      if (this.undo_stack.length >= this.undo_history_size) {
        this.undo_stack.shift();
      }
      return this.undo_stack.push(state);
    };

    FSMDesigner.prototype.save_redo_step = function() {
      if (this.redo_stack.length >= this.redo_history_size) {
        this.redo_stack.shift();
      }
      return this.redo_stack.push(this.dehydrate());
    };

    FSMDesigner.prototype.save_text_undo_step = function(force) {
      var cancel_timeout,
        _this = this;
      if (force == null) {
        force = false;
      }
      cancel_timeout = function() {
        return _this.text_entry_timout = null;
      };
      if (this.text_entry_timeout != null) {
        clearTimeout(this.text_entry_timeout);
      }
      if (!this.text_entry_timeout || force) {
        this.save_undo_step();
      }
      return this.text_entry_timeout = setTimeout(cancel_timeout, this.text_undo_delay);
    };

    FSMDesigner.prototype.serialize = function() {
      return JSON.stringify(this.dehydrate());
    };

    FSMDesigner.prototype.start_moving_selected = function(mouse) {
      var _base;
      this.save_undo_step();
      this.moving_object = true;
      this.delta_mouse_x = this.delta_mouse_y = 0;
      if (typeof (_base = this.selected).set_mouse_start === "function") {
        _base.set_mouse_start(mouse.x, mouse.y);
      }
      return this.reset_caret();
    };

    FSMDesigner.prototype.toggle_caret = function() {
      this.caret_visible = !this.caret_visible;
      return this.draw();
    };

    FSMDesigner.prototype.undo = function() {
      if (this.undo_stack.length === 0) {
        return;
      }
      this.save_redo_step();
      this.recreate_state(this.undo_stack.pop());
      return this.draw();
    };

    FSMDesigner.states_equivalent = function(a, b) {
      return JSON.stringify(a) === JSON.stringify(b);
    };

    return FSMDesigner;

  })();

  Transition = (function() {

    function Transition(source, destination, parent) {
      this.source = source;
      this.destination = destination;
      this.parent = parent;
      this.is_selected = __bind(this.is_selected, this);
      this.font = '16px "Inconsolata", monospace';
      this.fg_color = 'black';
      this.bg_color = 'white';
      this.selected_color = 'blue';
      this.text = '';
      this.line_angle_adjustment = 0;
      this.parallel_part = 0.5;
      this.perpendicular_part = 0;
      this.snap_to_straight_padding = this.parent.snap_to_padding;
    }

    Transition.prototype.apply_transition_color = function(context) {
      if (this.parent.selected === this) {
        return context.fillStyle = context.strokeStyle = this.selected_color;
      } else {
        return context.fillStyle = context.strokeStyle = this.fg_color;
      }
    };

    Transition.prototype.connected_to = function(state) {
      return this.source === state || this.destination === state;
    };

    Transition.prototype.contains_point = function(x, y) {
      return this.get_path().contains_point(x, y);
    };

    Transition.draw_arrow = function(context, x, y, angle) {
      var dx, dy;
      dx = Math.cos(angle);
      dy = Math.sin(angle);
      context.beginPath();
      context.moveTo(x, y);
      context.lineTo(x - 8 * dx + 5 * dy, y - 8 * dy - 5 * dx);
      context.lineTo(x - 8 * dx - 5 * dy, y - 8 * dy + 5 * dx);
      return context.fill();
    };

    Transition.prototype.draw_using = function(context) {
      this.apply_transition_color(context);
      return this.get_path().draw_using(context, this.text, this.font, this.is_selected());
    };

    Transition.prototype.get_deltas = function() {
      var displacement, dx, dy;
      dx = this.destination.x - this.source.x;
      dy = this.destination.y - this.source.y;
      displacement = {
        x: dx,
        y: dy,
        scale: Math.sqrt(dx * dx + dy * dy)
      };
      return displacement;
    };

    Transition.prototype.get_path = function() {
      if (this.perpendicular_part === 0) {
        return this.get_path_straight_line();
      } else {
        return this.get_path_curved_line();
      }
    };

    Transition.prototype.get_path_curved_line = function() {
      var anchor, circle, end, end_angle, reverse_scale, reversed, start, start_angle;
      console.log("Drawing a curved line at " + this.parallel_part + ", " + this.perpendicular_part + ".");
      anchor = this.get_location();
      circle = CurvedPath.circle_from_three_points(this.source, this.destination, anchor);
      reversed = this.perpendicular_part > 0;
      reverse_scale = reversed ? 1 : -1;
      start_angle = Math.atan2(this.source.y - circle.y, this.source.x - circle.x) - reverse_scale * this.source.radius / circle.radius;
      end_angle = Math.atan2(this.destination.y - circle.y, this.destination.x - circle.x) + reverse_scale * this.destination.radius / circle.radius;
      start = {
        x: circle.x + circle.radius * Math.cos(start_angle),
        y: circle.y + circle.radius * Math.sin(start_angle),
        angle: start_angle
      };
      end = {
        x: circle.x + circle.radius * Math.cos(end_angle),
        y: circle.y + circle.radius * Math.sin(end_angle),
        angle: end_angle
      };
      return new CurvedPath(start, end, circle, reversed);
    };

    Transition.prototype.get_path_straight_line = function() {
      var end, mid, start;
      mid = {
        x: (this.source.x + this.destination.x) / 2,
        y: (this.source.y + this.destination.y) / 2
      };
      start = this.source.closest_point_on_border(mid);
      end = this.destination.closest_point_on_border(mid);
      return new StraightPath(start, end);
    };

    Transition.prototype.get_location = function() {
      var d, location;
      d = this.get_deltas();
      location = {
        x: this.source.x + d.x * this.parallel_part - d.y * this.perpendicular_part / d.scale,
        y: this.source.y + d.y * this.parallel_part + d.x * this.perpendicular_part / d.scale
      };
      return location;
    };

    Transition.prototype.is_almost_straight = function() {
      return this.parallel_part > 0 && this.parallel_part < 1 && Math.abs(this.perpendicular_part) < this.snap_to_straight_padding;
    };

    Transition.prototype.is_selected = function() {
      return this.parent.selected === this;
    };

    Transition.prototype.move_to = function(point) {
      var d, offset_x, offset_y;
      d = this.get_deltas();
      offset_x = point.x - this.source.x;
      offset_y = point.y - this.source.y;
      this.parallel_part = (d.x * offset_x + d.y * offset_y) / (d.scale * d.scale);
      this.perpendicular_part = (d.x * offset_y - d.y * offset_x) / d.scale;
      if (this.is_almost_straight()) {
        return this.snap_to_straight();
      }
    };

    Transition.prototype.move_with_offset = function(point) {
      return this.move_to(point);
    };

    Transition.prototype.snap_to_straight = function() {
      this.line_angle_adjustment = (this.perpendicular_part < 0) * Math.PI;
      return this.perpendicular_part = 0;
    };

    return Transition;

  })();

  SelfTransition = (function(_super) {

    __extends(SelfTransition, _super);

    function SelfTransition(source, parent, created_at) {
      if (created_at == null) {
        created_at = null;
      }
      SelfTransition.__super__.constructor.call(this, source, source, parent);
      this.scale = 0.75;
      this.circumference_stroke = 0.8;
      this.snap_to_right_angle_radians = 0.1;
      this.anchor_angle = 0;
      this.mouse_offset_angle = 0;
      if (created_at != null) {
        this.move_to(created_at);
      }
    }

    SelfTransition.prototype.move_to = function(point) {
      var angle, dx, dy, right_angle;
      dx = point.x - this.source.x;
      dy = point.y - this.source.y;
      angle = Math.atan2(dy, dx) + this.mouse_offset_angle;
      right_angle = Math.round(angle / (Math.PI / 2)) * (Math.PI / 2);
      if (Math.abs(angle - right_angle) < this.snap_to_right_angle_radians) {
        angle = right_angle;
      }
      if (angle < -Math.PI) {
        angle += 2 * Math.PI;
      }
      if (angle > Math.PI) {
        angle -= 2 * Math.PI;
      }
      return this.anchor_angle = angle;
    };

    SelfTransition.prototype.move_with_offset = function(point) {
      return this.move_to(point);
    };

    SelfTransition.prototype.get_path = function() {
      var circle, diameter_scale, end, end_angle, start, start_angle;
      diameter_scale = this.scale * 2;
      circle = {
        x: this.source.x + diameter_scale * this.source.radius * Math.cos(this.anchor_angle),
        y: this.source.y + diameter_scale * this.source.radius * Math.sin(this.anchor_angle),
        radius: this.scale * this.source.radius
      };
      start_angle = this.anchor_angle - Math.PI * this.circumference_stroke;
      start = {
        x: circle.x + circle.radius * Math.cos(start_angle),
        y: circle.y + circle.radius * Math.sin(start_angle),
        angle: start_angle
      };
      end_angle = this.anchor_angle + Math.PI * this.circumference_stroke;
      end = {
        x: circle.x + circle.radius * Math.cos(end_angle),
        y: circle.y + circle.radius * Math.sin(end_angle),
        angle: end_angle
      };
      console.log("Creating circle at " + circle.radius + ".");
      return new CircularPath(start, end, circle, this.anchor_angle, this.circumference_stroke);
    };

    return SelfTransition;

  })(Transition);

  ResetTransition = (function(_super) {

    __extends(ResetTransition, _super);

    function ResetTransition(destination, parent, position) {
      if (position == null) {
        position = null;
      }
      ResetTransition.__super__.constructor.call(this, null, destination, parent);
      this.origin = {
        x: 0,
        y: 0
      };
      if (position != null) {
        this.anchor_at(position.x, position.y);
      }
    }

    ResetTransition.prototype.anchor_at = function(x, y) {
      this.origin.x = x - this.destination.x;
      return this.origin.y = y - this.destination.y;
    };

    ResetTransition.prototype.get_path = function() {
      var end, start;
      start = {
        x: this.destination.x + this.origin.x,
        y: this.destination.y + this.origin.y
      };
      end = this.destination.closest_point_on_border(start);
      return new StraightPath(start, end);
    };

    return ResetTransition;

  })(Transition);

  TransitionPlaceholder = (function() {

    function TransitionPlaceholder(start, end) {
      this.start = start;
      this.end = end;
      this.color = 'black';
    }

    TransitionPlaceholder.prototype.get_path = function() {
      return new StraightPath(this.start, this.end);
    };

    TransitionPlaceholder.prototype.draw_using = function(context) {
      context.fillStyle = context.strokeStyle = this.color;
      return this.get_path().draw_using(context);
    };

    return TransitionPlaceholder;

  })();

  StraightPath = (function() {

    function StraightPath(start, end) {
      this.start = start;
      this.end = end;
    }

    StraightPath.prototype.contains_point = function(x, y, tolerance) {
      var distance, dx, dy, length, offset_x, offset_y, percent;
      if (tolerance == null) {
        tolerance = 20;
      }
      dx = this.end.x - this.start.x;
      dy = this.end.y - this.start.y;
      offset_x = x - this.start.x;
      offset_y = y - this.start.y;
      length = Math.sqrt(dx * dx + dy * dy);
      percent = (dx * offset_x + dy * offset_y) / (length * length);
      distance = (dx * offset_y - dy * offset_x) / length;
      return percent > 0 && percent < 1 && Math.abs(distance) < tolerance;
    };

    StraightPath.prototype.draw_using = function(context, text, font, is_selected) {
      var text_location;
      if (text == null) {
        text = null;
      }
      if (font == null) {
        font = null;
      }
      if (is_selected == null) {
        is_selected = false;
      }
      context.beginPath();
      context.moveTo(this.start.x, this.start.y);
      context.lineTo(this.end.x, this.end.y);
      context.stroke();
      Transition.draw_arrow(context, this.end.x, this.end.y, this.get_arrow_angle());
      if (!((text != null) || is_selected)) {
        return;
      }
      text_location = {
        x: (this.start.x + this.end.x) / 2,
        y: (this.start.y + this.end.y) / 2,
        angle: Math.atan2(this.end.x - this.start.x, this.start.y - this.end.y)
      };
      return FSMDesigner.draw_text(context, text, text_location.x, text_location.y, is_selected, font, text_location.angle);
    };

    StraightPath.prototype.get_arrow_angle = function() {
      var arrow_angle;
      return arrow_angle = Math.atan2(this.end.y - this.start.y, this.end.x - this.start.x);
    };

    return StraightPath;

  })();

  CurvedPath = (function() {

    function CurvedPath(start, end, circle, reversed) {
      this.start = start;
      this.end = end;
      this.circle = circle;
      this.reversed = reversed;
    }

    CurvedPath.circle_from_three_points = function(d, e, f) {
      var a, b, c, circle, d_hypotenuse_squared, e_hypotenuse_squared, f_hypotenuse_squared;
      d_hypotenuse_squared = d.x * d.x + d.y * d.y;
      e_hypotenuse_squared = e.x * e.x + e.y * e.y;
      f_hypotenuse_squared = f.x * f.x + f.y * f.y;
      a = CurvedPath.determinant_3x3(d.x, d.y, 1, e.x, e.y, 1, f.x, f.y, 1);
      b = {
        x: -1 * CurvedPath.determinant_3x3(d_hypotenuse_squared, d.y, 1, e_hypotenuse_squared, e.y, 1, f_hypotenuse_squared, f.y, 1),
        y: CurvedPath.determinant_3x3(d_hypotenuse_squared, d.x, 1, e_hypotenuse_squared, e.x, 1, f_hypotenuse_squared, f.x, 1)
      };
      c = -1 * CurvedPath.determinant_3x3(d_hypotenuse_squared, d.x, d.y, e_hypotenuse_squared, e.x, e.y, f_hypotenuse_squared, f.x, f.y);
      circle = {
        x: -1 * b.x / (2 * a),
        y: -1 * b.y / (2 * a),
        radius: Math.sqrt(b.x * b.x + b.y * b.y - 4 * a * c) / (2 * Math.abs(a))
      };
      console.log(circle);
      return circle;
    };

    CurvedPath.determinant_3x3 = function(a, b, c, d, e, f, g, h, i) {
      return a * e * i + b * f * g + c * d * h - a * f * h - b * d * i - c * e * g;
    };

    CurvedPath.prototype.contains_point = function(x, y, tolerance) {
      var angle, distance, dx, dy, end_angle, start_angle;
      if (tolerance == null) {
        tolerance = 20;
      }
      dx = x - this.circle.x;
      dy = y - this.circle.y;
      distance = Math.abs(Math.sqrt(dx * dx + dy * dy) - this.circle.radius);
      if (distance > tolerance) {
        return false;
      } else {
        angle = Math.atan(dx, dy);
        if (this.reversed) {
          start_angle = this.end.angle;
          end_angle = this.start.angle;
        } else {
          start_angle = this.start.angle;
          end_angle = this.end.angle;
        }
        if (end_angle < start_angle) {
          end_angle += Math.PI * 2;
        }
        if (angle < start_angle) {
          angle += Math.PI * 2;
        } else if (angle > end_angle) {
          angle -= Math.PI * 2;
        }
        return angle > start_angle && angle < end_angle;
      }
    };

    CurvedPath.prototype.draw_using = function(context, text, font, is_selected) {
      var end_angle, text_angle, text_location;
      if (text == null) {
        text = null;
      }
      if (font == null) {
        font = null;
      }
      if (is_selected == null) {
        is_selected = false;
      }
      context.beginPath();
      context.arc(this.circle.x, this.circle.y, this.circle.radius, this.start.angle, this.end.angle, this.reversed);
      context.stroke();
      Transition.draw_arrow(context, this.end.x, this.end.y, this.get_arrow_angle());
      if (!((text != null) || is_selected)) {
        return;
      }
      end_angle = this.end.angle < this.start.angle ? this.end.angle + Math.PI * 2 : this.end.angle;
      text_angle = (this.start.angle + end_angle) / 2 + (this.reversed * Math.PI);
      text_location = {
        x: this.circle.X + this.circle.radius * Math.cos(text_angle),
        y: this.circle.X + this.circle.radius * Math.sin(text_angle),
        angle: text_angle
      };
      return FSMDesigner.draw_text(context, text, text_location.x, text_location.y, is_selected, font, text_location.angle);
    };

    CurvedPath.prototype.get_arrow_angle = function() {
      var scale;
      scale = this.reversed ? 1 : -1;
      return this.end.angle - scale * (Math.PI / 2);
    };

    return CurvedPath;

  })();

  CircularPath = (function() {

    function CircularPath(start, end, circle, anchor_angle, stroke_circumference) {
      this.start = start;
      this.end = end;
      this.circle = circle;
      this.anchor_angle = anchor_angle;
      this.stroke_circumference = stroke_circumference;
    }

    CircularPath.prototype.contains_point = function(x, y, tolerance) {
      var distance, dx, dy;
      if (tolerance == null) {
        tolerance = 20;
      }
      dx = x - this.circle.x;
      dy = y - this.circle.y;
      distance = Math.abs(Math.sqrt(dx * dx + dy * dy));
      return distance >= (this.circle.radius - tolerance) && distance <= (this.circle.radius + tolerance);
    };

    CircularPath.prototype.draw_using = function(context, text, font, is_selected) {
      var text_location;
      if (text == null) {
        text = null;
      }
      if (font == null) {
        font = null;
      }
      if (is_selected == null) {
        is_selected = false;
      }
      context.beginPath();
      context.arc(this.circle.x, this.circle.y, this.circle.radius, this.start.angle, this.end.angle, false);
      context.stroke();
      Transition.draw_arrow(context, this.end.x, this.end.y, this.end.angle + Math.PI * this.stroke_circumference / 2);
      if (!((text != null) || is_selected)) {
        return;
      }
      text_location = {
        x: this.circle.x + this.circle.radius * Math.cos(this.anchor_angle),
        y: this.circle.y + this.circle.radius * Math.sin(this.anchor_angle)
      };
      return FSMDesigner.draw_text(context, text, text_location.x, text_location.y, this.anchor_angle, font, is_selected);
    };

    return CircularPath;

  })();

  State = (function() {

    function State(x, y, parent) {
      this.x = x;
      this.y = y;
      this.parent = parent;
      this.radius = 55;
      this.accept_radius = 50;
      this.outline = 2;
      this.fg_color = 'black';
      this.bg_color = 'white';
      this.selected_color = 'blue';
      this.font = '16px "Droid Sans", sans-serif';
      this.output_padding = 14;
      this.output_font = '20px "Inconsolata", monospace';
      this.output_color = '#101010';
      this.grab_point = {
        x: 0,
        y: 0
      };
      this.is_accept_state = false;
      this.text = '';
      this.outputs = '';
    }

    State.prototype.closest_point_on_border = function(point) {
      var dx, dy, hypotenuse, x_leg, y_leg;
      dx = point.x - this.x;
      dy = point.y - this.y;
      hypotenuse = Math.sqrt(dx * dx + dy * dy);
      x_leg = dx * (this.radius / hypotenuse);
      y_leg = dy * (this.radius / hypotenuse);
      return point = {
        x: this.x + x_leg,
        y: this.y + y_leg
      };
    };

    State.prototype.contains_point = function(x, y, tolerance) {
      var distance, dx, dy;
      if (tolerance == null) {
        tolerance = 0;
      }
      dx = x - this.x;
      dy = y - this.y;
      distance = (dx * dx) + (dy * dy);
      return distance <= (this.radius + tolerance) * (this.radius + tolerance);
    };

    State.prototype.distance_to = function(object) {
      var distance;
      distance = {
        x: object.x - this.x,
        y: object.y - this.y
      };
      return Math.sqrt(distance.x * distance.x + distance.y * distance.y);
    };

    State.prototype.draw_using = function(context) {
      var output_y;
      context.lineWidth = this.outline;
      context.fillStyle = this.bg_color;
      context.strokeStyle = this.get_fg_color();
      context.beginPath();
      context.arc(this.x, this.y, this.radius, 0, Math.PI * 2, false);
      context.fill();
      context.stroke();
      if (this.is_accept_state) {
        context.beginPath();
        context.arc(this.x, this.y, this.accept_radius, Math.PI * 2, false);
        context.stroke();
      }
      context.fillStyle = this.get_fg_color();
      FSMDesigner.draw_text(context, this.text, this.x, this.y, this.selected && !this.in_output_mode, this.font);
      context.fillStyle = this.get_fg_color(true);
      output_y = this.y + this.radius + this.output_padding;
      return FSMDesigner.draw_text(context, this.outputs, this.x, output_y, this.selected && this.in_output_mode, this.output_font);
    };

    State.prototype.get_fg_color = function(is_output) {
      if (is_output == null) {
        is_output = false;
      }
      if (this.is_selected() && this.in_output_mode && is_output) {
        return this.selected_color;
      } else if (this.is_selected() && this.in_output_mode) {
        return this.fg_color;
      } else if (this.is_selected() && !is_output) {
        return this.selected_color;
      } else {
        return this.fg_color;
      }
    };

    State.prototype.move_to = function(point) {
      this.x = point.x;
      return this.y = point.y;
    };

    State.prototype.move_with_offset = function(point) {
      this.x = point.x + this.grab_point.x;
      return this.y = point.y + this.grab_point.y;
    };

    State.prototype.is_selected = function() {
      return this.parent.selected === this;
    };

    State.prototype.set_mouse_start = function(x, y) {
      return this.grab_point = {
        x: this.x - x,
        y: this.y - y
      };
    };

    return State;

  })();

  window.FSMDesigner = FSMDesigner;

}).call(this);
